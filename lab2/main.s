# Инверсия старших битов беззнаковых слов
# Суммирование четных новых элементов 

# Данные
.data

# Массив из 10 слов
array:
    .short 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
array_end:

# Формат вывода итогового результата
sum_format:
    .string "SUM: %u\n"


.text
.global main

# Начало программы
main:
    # Обнуление промежуточного регистра
    xorl %eax, %eax
    # Получение адреса первого эл. массива
    movl $array, %ebx

proc:
    # Получаем значение массива
    movw (%ebx), %ax
    # Инверсия старших бит
    not %ah
    # Перезапись значения в массиве
    movw %ax, (%ebx)

    # Переход к след. элементу
    addl $2, %ebx
    # Проверка на окончание массива
    cmp $array_end, %ebx
    # Если массив не закончился, то прыжок на proc 
    jne proc


    # Обнуление суммы
    xorl %edx, %edx
    # Адрес первого эл. массива
    movl $array, %ebx
sum: 
    # Получить значение массива
    movw (%ebx), %ax
    # Суммирование
    addl %eax, %edx

    # Переход на 2 эл. вперед
    addl $4, %ebx
    # Сравнение с концом массива
    cmpl $array_end, %ebx
    # Если не конец, то прыгаем в sum
    jl sum


    # Вывод результата    
    pushl %edx
    pushl $sum_format
    call printf

    # Окончание программы
    movl $1, %eax
    movl $0, %ebx
    int $0x80

